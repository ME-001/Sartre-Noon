<!--
 //==============================================================================
 //  refEventGeneratorSettings.html
 //
 //  Copyright (C) 2010-2013 Tobias Toll and Thomas Ullrich 
 //
 //  This file is part of Sartre version: 1.1 
 //
 //  This program is free software: you can redistribute it and/or modify 
 //  it under the terms of the GNU General Public License as published by 
 //  the Free Software Foundation.   
 //  This program is distributed in the hope that it will be useful, 
 //  but without any warranty; without even the implied warranty of 
 //  merchantability or fitness for a particular purpose. See the 
 //  GNU General Public License for more details. 
 //  You should have received a copy of the GNU General Public License
 //  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 //
 //  Author: Thomas Ullrich
 //  Last update: 
 //  $Date: 2013-05-29 16:25:21 -0400 (Wed, 29 May 2013) $
 //  $Author: thomas.ullrich@bnl.gov $
 //==============================================================================
 -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
    <head>
        <title>Sartre - EventGeneratorSettings Class Reference</title>
        <meta http-equiv="Content-type" content="text/html; charset=UTF-8" />  <link href="sartre.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <table border="0" cellpadding="0" cellspacing="0" width="100%">
            <tr>
                <td width="120" align="left" valign="top"><img src="images/sartreLogo.png" alt="" border="0" align="right" /></td>
                <td width="10">&nbsp;&nbsp;</td>
                <td align="left" valign="middle" class="postheader"><a href="index.html"><font color="#004faf">Home</font></a>&nbsp;&middot; 
                    <a href="overview.html"><font color="#004faf">Overview</font></a>&nbsp;&middot; 
                    <a href="usersGuide.html"><font color="#004faf">Users Guide</font></a>&nbsp;&middot; 
                    <a href="referenceGuide.html"><font color="#004faf">Reference Guide</font> </a></td></tr>
        </table>
        <h1 class="title"> EventGeneratorSettings Class Reference</h1>
        <p>EventGeneratorSettings holds Sartre's run and configuration parameters. <a href="#details">More...</a></p>
        <pre><span class="preprocessor"> #include</span> "EventGeneratorSettings.h"</pre>
        <h2>Inheritance</h2>
        <p>Inherits from virtual class <a href="refSettings.html">Settings</a>.</p>
        <hr>
        <h2>Public  Member Functions</h2>
        <table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
            <tbody>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    static EventGeneratorSettings* </td>
                    <td class="memItemRight" valign="top"><a href="#instance">instance</a>()               </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setVerbose">setVerbose</a>(bool)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    bool </td>
                    <td class="memItemRight" valign="top"><a href="#verbose">verbose</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setVerboseLevel">setVerboseLevel</a>(int)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    int </td>
                    <td class="memItemRight" valign="top"><a href="#verboseLevel">verboseLevel</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setNumberOfEvents">setNumberOfEvents</a>(unsigned long)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    unsigned long </td>
                    <td class="memItemRight" valign="top"><a href="#numberOfEvents">numberOfEvents</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setTimesToShow">setTimesToShow</a>(unsigned int)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    unsigned int </td>
                    <td class="memItemRight" valign="top"><a href="#timesToShow">timesToShow</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setQ2min">setQ2min</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#Q2min">Q2min</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#Qmin">Qmin</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setQ2max">setQ2max</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#Q2max">Q2max</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#Qmax">Qmax</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setWmin">setWmin</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setW2min">setW2min</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#Wmin">Wmin</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#W2min">W2min</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setWmax">setWmax</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setW2max">setW2max</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#Wmax">Wmax</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#W2max">W2max</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    int </td>
                    <td class="memItemRight" valign="top"><a href="#vectorMesonId">vectorMesonId</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setVectorMesonId">setVectorMesonId</a>(int)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#electronBeamEnergy">electronBeamEnergy</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setElectronBeamEnergy">setElectronBeamEnergy</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#hadronBeamEnergy">hadronBeamEnergy</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setHadronBeamEnergy">setHadronBeamEnergy</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    TLorentzVector </td>
                    <td class="memItemRight" valign="top"><a href="#eBeam">eBeam</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    TLorentzVector </td>
                    <td class="memItemRight" valign="top"><a href="#hBeam">hBeam</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    string          </td>
                    <td class="memItemRight" valign="top"><a href="#dipoleModelName">dipoleModelName</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    <a href="refEnumerations.html">DipoleModelType</a></td>
                    <td class="memItemRight" valign="top"><a href="#dipoleModelType">dipoleModelType</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setDipoleModelType">setDipoleModelType</a>(<a href="refEnumerations.html">DipoleModelType</a>) </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    string </td>
                    <td class="memItemRight" valign="top"><a href="#rootfile">rootfile</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setRootfile">setRootfile</a>(const char*)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    unsigned int </td>
                    <td class="memItemRight" valign="top"><a href="#A">A</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setA">setA</a>(unsigned int)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    bool </td>
                    <td class="memItemRight" valign="top"><a href="#correctForRealAmplitude">correctForRealAmplitude</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setCorrectForRealAmplitude">setCorrectForRealAmplitude</a>(bool)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    bool </td>
                    <td class="memItemRight" valign="top"><a href="#correctSkewedness">correctSkewedness</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setCorrectSkewedness">setCorrectSkewedness</a>(bool)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    bool </td>
                    <td class="memItemRight" valign="top"><a href="#enableNuclearBreakup">enableNuclearBreakup</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setEnableNuclearBreakup">setEnableNuclearBreakup</a>(bool)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#maxNuclearExcitationEnergy">maxNuclearExcitationEnergy</a>()  const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setMaxNuclearExcitationEnergy">setMaxNuclearExcitationEnergy</a>(double)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="#maxLambdaUsedInCorrections">maxLambdaUsedInCorrections</a>()
                        const         </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setMaxLambdaUsedInCorrections">setMaxLambdaUsedInCorrections</a>(double)  </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    bool </td>
                    <td class="memItemRight" valign="top"><a href="#applyPhotonFlux">applyPhotonFlux</a>()  const </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setApplyPhotonFlux">setApplyPhotonFlux</a>(bool)          </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    bool </td>
                    <td class="memItemRight" valign="top"><a href="#UPC">UPC</a>() const  </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setUPC">setUPC</a>(bool)  </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    unsigned int </td>
                    <td class="memItemRight" valign="top"><a href="#UPCA">UPCA</a>() const  </td>
                </tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="#setUPCA">setUPCA</a>(unsigned int)  </td>

                </tr>

            </tbody></table>
        <h2>Inherited Public  Member Functions</h2>
        <table class="alignedsummary" border="0" cellpadding="0" cellspacing="0" width="100%">
            <tbody>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    bool </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#readSettingsFromFile">readSettingsFromFile</a>(const char*)          </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    virtual bool </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#list">list</a>(ostream&amp; = cout)                   </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    TParticlePDG*     </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#lookupPDG">lookupPDG</a>(int)  const         </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    string            </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#particleName">particleName</a>(int pdgID)          </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    static TRandom3*  </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#randomGenerator">randomGenerator</a>()                 </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    unsigned int </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#seed">seed</a>()  const         </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#setSeed">setSeed</a>(unsigned int)        </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    int </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#userInt">userInt</a>()  const</td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    double </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#userDouble">userDouble</a>()  const</td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    string </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#userString">userString</a>()  const</td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#setUserInt">setUserInt</a>(int)  </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#setUserDouble">setUserDouble</a>(double)  </td></tr>
                <tr>
                    <td class="memItemLeft" align="right" valign="top">    void </td>
                    <td class="memItemRight" valign="top"><a href="refSettings.html#setUserString">setUserString</a>(const string&amp;)  </td></tr>
            </tbody></table>
        <hr>
        <h2><a name="details" id="details"></a>Detailed Description</h2>
        <p>The main API for event generation is  class <a href="refSartre.html">Sartre</a>.
        However, Sartre  does not handle  its settings parameters 
        at all but defers that job to the &quot;Settings&quot; classes. These classes
        are not only simple containers for parameters but provide lots of functionality
        to load, print, and manage parameters and also provide some particle lookup
        features. 
        The basic functionality is provided by the <a href="refSettings.html">Settings</a> class,
        inherited by the EventGeneratorSettings class. For creating the amplitude table a
        separate  class needs to be used (TableGeneratorSettings),
        EventGeneratorSettings
        only deals with the parameter needed for generating events and/or calculating
        cross-sections.
        <p>EventGeneratorSettings is a singleton class, i.e., only one instance exist at any
        time. One can always obtain the actual instance using the static <a href="#instance">instance()</a> method.
        For example:
        <pre class="code">
            // somewhere in your code
            EventGeneratorSettings* mySettings = EventGeneratorSettings::instance();</pre>
        
        <p>The more conventional (and preferred) way of obtaining the actual instance
        is through your instance of <a href="refSartre.html">Sartre</a>.
        <pre class="code">
            Sartre mySartre;
            EventGeneratorSettings* mySettings = mySartre::runSettings();</pre>
        <p>EventGeneratorSettings (via Settings) also provides the &quot;runcard&quot; mechanism,
        that is the possibility to store all parameters to run Sartre in a text file
        (the <a href="runcardRef.html">runcard</a>) and read them in (see <a href="refSartre.html#init">Sartre::init()</a> for details).
        <p>Parameters managed by EventGeneratorSettings can be set and used via access functions.
        Each access function has an equivalent <a href="runcardRef.html">runcard</a> name.
        For more on see the <a href="refSartre.html#details">detailed documentation</a> on
        the Sartre class page where also the default values for all parameters are
        listed.
        <p>Several of the parameters listed here are strictly not mandatory to run Sartre.
        The are only provided for convenience to allow the user to control his program
        through a runcard allowing multiple runs with different parameters without
        the need to recompile. Two examples are the &quot;number of events&quot;
        and
        the &quot;times to show&quot; parameter. Here is an example on how to make
        effective use of them:
        <pre class="code">
            int nPrint;   
            if (settings->timesToShow())   
            nPrint = settings->numberOfEvents()/settings->timesToShow();   
            else    
            nPrint = 0;   
            
            
            for (unsigned long iEvent = 0; iEvent < settings-&gt;numberOfEvents(); iEvent++) {   
                //   
                //  Generate one event   
                //   
                Event *event = sartre.generateEvent();   
                if (nPrint && iEvent%nPrint == 0 && iEvent != 0) {   
                cout << "processed " << iEvent << " events" << endl;   
                }
                // you code here
                }</pre>
                <p>If the timesToShow parameter was set to 20, the status is printed out exactly
                20 times independent of the number of events. The number of events to process
                can be controlled through the runcard.
                <p>Note that  parameters should not be changed after the call to <a href="refSartre.html#init">Sartre::init()</a>.
                <hr> 
                <h2>Public Member Function Documentation</h2>
                <h3 class="fn"><span class="memItemRight"><a name="instance" id="instance"></a>    static EventGeneratorSettings*   instance()                </span></h3>
                <p>Static method returning a pointer to self. Note, that there is no public
                constructor for EventGeneratorSettings. The only way to get an instance is through
                this method.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setVerbose" id="setVerbose"></a>    void
                    setVerbose(bool <var>value</var>) </span></h3> <p>Switches verbosity
                on or off. Equivalent runcard entry is <a href="runcardRef.html#verbose">verbose</a>.</p>
                <h3 class="fn"><span class="memItemRight"><a name="verbose" id="verbose"></a>    bool   verbose()   const         </span></h3>
                <p>Returns verbosity flag.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setVerboseLevel" id="setVerboseLevel"></a>    void
                    setVerboseLevel(int <var>value</var>) </span></h3>
                <p>Sets the verbosity level to <var>value</var>. Higher values than 1 or 2
                are for debugging purposes only. If &gt; 0 automatically sets the verbose
                flag (see above) to true. Equivalent runcard entry is <a href="runcardRef.html#verboseLevel">verboseLevel</a>. </p>
                <h3 class="fn"><span class="memItemRight"><a name="verboseLevel" id="verboseLevel"></a>    int   verboseLevel()   const         </span></h3>
                <p>Returns the verbosity level (0,1,2,...).</p>
                <h3 class="fn"><span class="memItemRight"><a name="setNumberOfEvents" id="setNumberOfEvents"></a>    void
                    setNumberOfEvents(unsigned long <var>value</var>) </span></h3>
                <p>Set number of events to generate to <var>value</var>. Equivalent runcard entry
                is <a href="runcardRef.html#numberOfEvents">numberOfEvents</a>.
                Note that this is a user parameter and is only added for convenience since
                it allows to set the number of events to generate through a runcard. See
                example program<code> sartreMain.cpp</code> for how to use.</p>
                <h3 class="fn"><span class="memItemRight"><a name="numberOfEvents" id="numberOfEvents"></a>    unsigned long   numberOfEvents()   const         </span></h3>
                <p>Returns the number of events to generate. See <span class="memItemRight"><a href="#setNumberOfEvents">setNumberOfEvents</a>(</span>).</p>
                <h3 class="fn"><span class="memItemRight"><a name="setTimesToShow" id="setTimesToShow"></a>    void
                    setTimesToShow(unsigned int <var>value</var>) </span></h3>
                <p>Defines how many times the current status (number of events generated so
                far) should be printed. Equivalent runcard entry
                is <a href="runcardRef.html#timesToShow">timesToShow</a>.
                Note that this is a user parameter and is only added for convenience since
                it allows to set this useful parameter through a runcard. See
                example program<code> sartreMain.cpp</code> for how to use, or example <a href="#details">above</a>.</p>
                <h3 class="fn"><span class="memItemRight"><a name="timesToShow" id="timesToShow"></a>    unsigned int   timesToShow()   const         </span></h3>
                <p>Returns user parameter meant to control status-printouts. See <span class="memItemRight"><a href="#setTimesToShow">setTimesToShow</a></span><a href="#setTimesToShow">()</a>.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setQ2min" id="setQ2min"></a>    void
                    setQ2min(double <var>value</var>) </span></h3>
                <p>Sets the minimum Q<sup>2</sup> in GeV<sup>2</sup> to generate to <var>value</var>.
                If Q2min > Q2max
                then the largest available range is used, either given by kinematics or the
                range of the available tables. Equivalent runcard entry
                is <a href="runcardRef.html#Q2min">Q2min</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="Q2min" id="Q2min"></a>    double   Q2min()   const         </span></h3>
                <p>Returns minimum Q<sup>2</sup> to generate (in GeV<sup>2</sup>). See also <a href="#setQ2min">setQ2min()</a>.
                Note that this is the parameter set by the user and is not necessarily the
                actual value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for
                details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="Qmin" id="Qmin"></a>    double   Qmin()   const         </span></h3>
                <p>Returns minimum Q to generate (in GeV). See also <a href="#setQ2min">setQ2min()</a> and
                <a href="#Q2min">Q2min()</a>. Alternative form to above using Q
                not Q<sup>2</sup>. Note that this is the parameter set
                by the user and is not necessarily the actual value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for
                details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="setQ2max" id="setQ2max"></a>    void
                    setQ2max(double <var>value</var>) </span></h3>
                <p>Sets the maximum Q<sup>2</sup> in GeV<sup>2</sup> to generate to <var>value</var>.
                If Q2min &gt; Q2max then the largest available range is used, either given
                by kinematics or the range of the available tables. Equivalent runcard entry
                is <a href="runcardRef.html#Q2max">Q2max</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="Q2max" id="Q2max"></a>    double   Q2max()   const         </span></h3>
                <p>Returns maximum Q<sup>2</sup> to generate (in GeV<sup>2</sup>). See also <a href="#setQ2max">setQ2max()</a>.
                Note that this is the parameter set by the user and is not necessarily the
                actual value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for
                details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="Qmax" id="Qmax"></a>    double   Qmax()   const         </span></h3>
                <p>Returns maximum Q to generate (in GeV). Alternative form to above using Q
                not Q<sup>2</sup>.
                See also <a href="#setQ2max">setQ2max()</a> and <a href="#Q2max">Q2max()</a>.
                Note that this is the parameter set by the user and is not necessarily the
                actual value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for
                details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="setWmin" id="setWmin"></a>    void
                    setWmin(double <var>value</var>) </span></h3>
                <p>Sets the minimum W<sup></sup> to generate (in GeV)  to <var>value</var>.
                If Wmin &gt; Wmax then the largest available range is used, either given
                by kinematics or the range of the available tables. Equivalent runcard entry
                is <a href="runcardRef.html#Wmin">Wmin</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="setW2min" id="setW2min"></a>    void
                    setW2min(double <var>value</var>) </span></h3>
                <p>Alternative form to above using W<sup>2</sup> not W. No runcard equivalent.</p>
                <h3 class="fn"><span class="memItemRight"><a name="Wmin" id="Wmin"></a>    double   Wmin()   const         </span></h3>
                <p>Returns minimum W to generate (in GeV). Note that this is the parameter set
                by the user and is not necessarily the actual value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for
                details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="W2min" id="W2min"></a>    double   W2min()   const         </span></h3>
                <p>Returns minimum W<sup>2</sup> to generate (in GeV<sup>2</sup>).  See also <a href="#setW2max">setW2min()</a> and <a href="#Wmin">Wmin()</a>.
                Note that this is the parameter set by the user and is not necessarily the actual
                value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="setWmax" id="setWmax"></a>    void
                    setWmax(double <var>value</var>) </span></h3>
                <p>Sets the maximum W<sup></sup> to generate (in GeV) to <var>value</var>. If
                Wmin &gt; Wmax then the largest available range is used, either given by
                kinematics or the range of the available tables. Equivalent runcard entry
                is <a href="runcardRef.html#Wmax">Wmax</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="setW2max" id="setW2max"></a>    void
                    setW2max(double <var>value</var>) </span></h3>
                <p>Alternative form to above using W<sup>2</sup> not W. No equivalent runcard.
                See also <a href="#setWmax">setWmax()</a>.</p>
                <h3 class="fn"><span class="memItemRight"><a name="Wmax" id="Wmax"></a>    double   Wmax()   const         </span></h3>
                <p>Returns maximum W to generate (in GeV). Note that this is the parameter set
                by the user and is not necessarily the actual value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for
                details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="W2max" id="W2max"></a>    double   W2max()   const         </span></h3>
                <p>Returns maximum W<sup>2</sup> to generate (in GeV<sup>2</sup>). Note that this is the parameter set
                by the user and is not necessarily the actual value used (see <a href="sartreRef.html#kinematicLimits2">here</a> for
                details).</p>
                <h3 class="fn"><span class="memItemRight"><a name="vectorMesonId" id="vectorMesonId"></a>    int   vectorMesonId()   const         </span></h3>
                <p>Returns PDG value of vector meson to be generated.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setVectorMesonId" id="setVectorMesonId"></a>    void
                    setVectorMesonId(int<var> ID</var>) </span></h3>
                <p>Sets  ID of vector meson to generate. Mesons are given using
                their PDG values. Equivalent runcard entry
                is <a href="runcardRef.html#vectorMesonId">vectorMesonId</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="electronBeamEnergy" id="electronBeamEnergy"></a>    double   electronBeamEnergy()   const         </span></h3>
                <p>Electron beam energy in GeV.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setElectronBeamEnergy" id="setElectronBeamEnergy"></a>    void
                    setElectronBeamEnergy(double <var>E</var>) </span></h3>
                <p>Sets electron beam energy to <var>E</var> (in GeV). Equivalent runcard entry
                is <a href="runcardRef.html#eBeamEnergy">eBeamEnergy</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="hadronBeamEnergy" id="hadronBeamEnergy"></a>    double   hadronBeamEnergy()   const         </span></h3>
                <p>Hadron beam energy on GeV. </p>
                <h3 class="fn"><span class="memItemRight"><a name="setHadronBeamEnergy" id="setHadronBeamEnergy"></a>    void
                    setHadronBeamEnergy(double <var>E</var>) </span></h3>
                <p>Sets electron beam energy to <var>E</var> (in GeV). Equivalent runcard entry
                is <a href="runcardRef.html#hBeamEnergy">hBeamEnergy</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="eBeam" id="eBeam"></a>    TLorentzVector   eBeam()   const         </span></h3>
                <p>Returns electron beam 4-vector. See <a href="http://root.cern.ch/root/html/TLorentzVector.html">ROOT
                    documentation</a> for TLorentzVector.</p>
                <h3 class="fn"><span class="memItemRight"><a name="hBeam" id="hBeam"></a>    TLorentzVector   hBeam()   const         </span></h3>
                <p>Returns hadron beam 4-vector. See <a href="http://root.cern.ch/root/html/TLorentzVector.html">ROOT
                    documentation</a> for TLorentzVector.</p>
                <h3 class="fn"><span class="memItemRight"><a name="dipoleModelName" id="dipoleModelName"></a>    string            dipoleModelName()   const         </span></h3>
                <p>Returns name of dipole Model used. </p>
                <h3 class="fn"><span class="memItemRight"><a name="dipoleModelType" id="dipoleModelType"></a>    <a href="refEnumerations.html">DipoleModelType</a> dipoleModelType()   const </span></h3>
                <p>Returns  dipole model used. </p>
                <h3 class="fn"><span class="memItemRight"><a name="setDipoleModelType" id="setDipoleModelType"></a>    void
                    setDipoleModelType(<a href="refEnumerations.html">DipoleModelType</a> <var>model</var>) </span></h3>
                <p>Sets dipole model to be used. Equivalent runcard entry
                is <a href="runcardRef.html#dipoleModel">dipoleModel</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="rootfile" id="rootfile"></a>    string   rootfile()   const         </span></h3>
                <p>Returns name of root file (or any output file name). See also <a href="#setRootfile">setRootfile()</a>.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setRootfile" id="setRootfile"></a>    void
                    setRootfile(const char* <var>filename</var>) </span></h3>
                <p>Sets name of root file (or any output file name). Note that this is a user
                parameter and is only added for convenience since it allows to set the name
                of the output file via runcards. See example program<code> sartreMain.cpp</code> on
                how to use. Equivalent runcard entry
                is <a href="runcardRef.html#rootfile">rootfile</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="A" id="A"></a>    unsigned int   A()   const         </span></h3>
                <p>Returns the (integer) mass of the hadron beam particle. </p>
                <h3 class="fn"><span class="memItemRight"><a name="setA" id="setA"></a>    void
                    setA(unsigned int <var>value</var>) </span></h3>
                <p>Returns the mass of the hadron beam particle to <var>value</var> (1=proton
                beam). Not that not all nuclei are implemented (see class <a href="nucleus.html">Nuclei</a> for
                details). Equivalent runcard entry
                is <a href="runcardRef.html#A">A</a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="correctForRealAmplitude" id="correctForRealAmplitude"></a>    bool   correctForRealAmplitude()   const         </span></h3>
                <p>Whether the correction for the missing real amplitude is switched
                on or off.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setCorrectForRealAmplitude" id="setCorrectForRealAmplitude"></a>    void
                    setCorrectForRealAmplitude(bool <var>value</var>) </span></h3>
                <p>Switch correction for real amplitude not being taken into account or or off.
                Equivalent runcard entry is <a href="runcardRef.html#correctForRealAmplitude"><span class="memItemRight">correctForRealAmplitude</span></a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="correctSkewedness" id="correctSkewedness"></a>    bool   correctSkewedness()   const         </span></h3>
                <p>Whether the skewedness correction  switched
                on or off.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setCorrectSkewedness" id="setCorrectSkewedness"></a>    void
                    setCorrectSkewedness(bool <var>value</var>) </span></h3>
                <p>Switch skewedness on or off. Equivalent runcard entry is <a href="runcardRef.html#correctSkewedness"><span class="memItemRight">correctSkewedness</span></a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="enableNuclearBreakup" id="enableNuclearBreakup"></a>    bool   enableNuclearBreakup()   const         </span></h3>
                <p>Returns if  nuclear break up for incoherent events is switched on or off.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setEnableNuclearBreakup" id="setEnableNuclearBreakup"></a>    void
                    setEnableNuclearBreakup(bool <var>value</var>) </span></h3>
                <p>Switch nuclear break up for incoherent events on or off. Equivalent runcard
                entry is <a href="runcardRef.html#enableNuclearBreakup"><span class="memItemRight">enableNuclearBreakup</span></a><code>.</code> Note
                that switching nuclear breakup on slows event generation down significantly.</p>
                <h3 class="fn"><span class="memItemRight"><a name="maxNuclearExcitationEnergy" id="maxNuclearExcitationEnergy"></a>    double   maxNuclearExcitationEnergy()   const         </span></h3>
                <p>Maximum excitation energy of  nuclei in incoherent events.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setMaxNuclearExcitationEnergy" id="setMaxNuclearExcitationEnergy"></a>    void
                    setMaxNuclearExcitationEnergy(double <var>E</var>) </span></h3>
                <p>Sets the maximum excitation energy of nuclei in incoherent events to <var>E</var> (in
                GeV). This is necessary since the underlying evaporation engine (Gemini)
                cannot handle too large energies. Equivalent runcard
                entry is <a href="runcardRef.html#maxNuclearExcitationEnergy"><span class="memItemRight">maxNuclearExcitationEnergy</span></a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="maxLambdaUsedInCorrections" id="maxLambdaUsedInCorrections"></a>    double   maxLambdaUsedInCorrections()   const         </span></h3>
                <p> Maximum log derivate of the amplitude used in corrections.</p>
                <h3 class="fn"><span class="memItemRight"><a name="setMaxLambdaUsedInCorrections" id="setMaxLambdaUsedInCorrections"></a>    void
                    setMaxLambdaUsedInCorrections(double <var>value</var>) </span></h3>
                <p>Sets the maximum log derivate of the amplitude used in corrections. See <span class="memItemRight"><a href="#setCorrectSkewedness">setCorrectSkewedness</a></span><a href="#setCorrectSkewedness">()</a> and <span class="memItemRight"><a href="#setCorrectForRealAmplitude">setCorrectForRealAmplitude</a></span><a href="#setCorrectForRealAmplitude">()</a>.
                Equivalent runcard entry is <a href="runcardRef.html#maxLambdaUsedInCorrections"><span class="memItemRight">maxLambdaUsedInCorrections</span></a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="applyPhotonFlux" id="applyPhotonFlux"></a>    bool   applyPhotonFlux()   const         </span></h3>
                <p>Returns flag that controls if the photon flux is applied to the cross-section
                or not. </p>
                <h3 class="fn"><span class="memItemRight"><a name="setApplyPhotonFlux" id="setApplyPhotonFlux"></a>    void
                    setApplyPhotonFlux(bool <var>value</var>) </span></h3>
                <p>Sets flag  to control if the photon flux is applied in the cross-section calculation
                or not. This should be always on in generator mode. There are few cases (see
                example program <code>heraCompare.cpp</code>) when Sartre is used to calculate cross-sections
                only, where this might be useful. For experts only. Equivalent runcard entry
                is <a href="runcardRef.html#applyPhotonFlux"><span class="memItemRight">applyPhotonFlux</span></a><code>.</code></p>
                <h3 class="fn"><span class="memItemRight"><a name="UPC" id="UPC"></a>    bool
                    UPC() const </span></h3>
                <p>
                Returns flag that controls weather to use UPC.
                </p>
                <h3 class="fn"><span class="memItemRight"><a name="setUPC" id="setUPC"></a>    void
                    setUPC(bool <var>value</var>) </span></h3>
                <p>
                Set flag to tell the program to simulate ultra peripheral collisions by using
                a photon flux from a proton or a nucleus, depending on the value of UPCA.
                Default value is <code>false</code>.                
                </p>
                <h3 class="fn"><span class="memItemRight"><a name="UPCA" id="UPCA"></a>    unsigned int 
                    UPCA() const </span></h3>
                <p>
                Returns the atomic number of the beam-particle that emits a (virtual) photon
                in UPC events. If <code>UPC=false</code>, this variable has no effect.
                </p>
                <h3 class="fn"><span class="memItemRight"><a name="setUPCA" id="setUPCA"></a>    void
                    setUPCA(unsigned int <var>value</var>)  </span></h3>
                <p>
                Sets the atomic number of the beam-particle that emits a (virtual) photon
                in a UPC event.
                </p>
                <p>&nbsp;</p>
                
                <address><div align="center">
                    <table border="0" cellspacing="0" width="100%"><tbody><tr class="address">
                        <td align="left" width="40%">&nbsp;</td>
                        <td align="center" width="20%">&nbsp;</td>
                        <td align="right" width="40%"><div align="right"><br>Last Update:
                            <!-- #BeginDate format:Am1 -->January 11, 2013<!-- #EndDate -->
                        </div></td>
                    </tr></tbody></table></div></address>
                
    </body></html>
