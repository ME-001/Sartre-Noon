//==============================================================================
//  DglapEvolution.h
//
//  Copyright (C) 2010-2019 Tobias Toll and Thomas Ullrich
//
//  This file is part of Sartre.
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation.
//  This program is distributed in the hope that it will be useful,
//  but without any warranty; without even the implied warranty of
//  merchantability or fitness for a particular purpose. See the
//  GNU General Public License for more details.
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
//  Author: Thomas Ullrich
//  $Date: 2019-09-18 11:32:50 -0400 (Wed, 18 Sep 2019) $
//  $Author: ullrich $
//==============================================================================
//  LO DGLAP evolution
//
//  This class is a singleton.
//
//  The evolution functions xG() and alphasxG()
//  take as arguments:
//
//   x :       Bjorken momentum fraction
//   Q2:       Virtuality in GeV^2
//
//  DglapEvolution::xG()       returns x*G(x, Q^2)
//  DglapEvolution::alphaSxG() returns alpha_s(Q^2)*x*G(x,Q^2)
//
//  This is a rewrite of code written in F77. The documentation is
//  largely left as provided in the Fortran version but includes
//  the updated variable and function names. Data originally stored
//  in common blocks and several static variables turned into data members.
//  Some relics of the original F77 code remained such as array
//  indexing starting at 1 (arrays are size +1 here).
//  The code was substantially simplified and is limited to work
//  only in LO.
//
//  Lookup Table:
//  To speed up things the class features a lookup table mechanism.
//  Lookup tables are generated by calling:
//
//  DglapEvolution::generateLookupTable(int nx = 200, int nq2 = 200);
//
//  where nx and nq2 is the granularity in x and Q2. Loopkup tables
//  are kept in memory. The method generateLookupTable() can be called
//  multiple times with different sized if needed. The use of the lookup
//  table is switched on or off at any time via:
//
//  DglapEvolution::useLookupTable(bool val);
//
//  If switched off the lookup table is *not* deleted. It just instructs
//  xG() to not use the lookup table.
//  The current state can be checked via lookupTableIsUsed().
//==============================================================================
#ifndef DglapEvolution_h
#define DglapEvolution_h
#include <complex>
#include <iostream>
#include "AlphaStrong.h"

using namespace std;

class DglapEvolution {
public:
    static DglapEvolution& instance();
    ~DglapEvolution();
    
    double  xG(double x, double Q2);
    double  alphaSxG(double x, double Q2);
    double  logDerivative(double x, double Q2); //  dlog(xG)/dlog(1/x)

    void generateLookupTable(int nx = 200, int nq2 = 200);
    void useLookupTable(bool);
    bool lookupTableIsUsed() const;
    
    void list(ostream& = cout);
    
private:
    DglapEvolution();

private:
    void anom();
    void anCalc(complex<double>& ggi, complex<double>& ggf, complex<double>& xn);
    complex<double> psiFunction(complex<double>);
    complex<double> lngam(complex<double> X);
    complex<double> beta(complex<double>, complex<double>);
    void reno(complex<double>* fn, double alpq, int nmax, double ag, double lambdag);
    
    double xG_Interpolator(double x, double Q2);
    double xG_Engine(double x, double Q2);
    double luovi( double f[4], double arg[4], double z);

private:
    static DglapEvolution* mInstance;

    double mMu02;
    double mAg;
    double mLambdaG;
    
    complex<double> mCC;
    complex<double> mAP[137][6];
    complex<double> mN[137];
    double mWN[137];
    double mC;
    double mALPS;
    double mALPC;
    double mALPB;
    double mALPT;
    double mMUR;
    double mMC;
    double mMB;
    double mMT;
    
    bool mLookupTableIsFilled;
    bool mUseLookupTable;
    unsigned int mNumberOfNodesInX;
    unsigned int mNumberOfNodesInQ2;
    double mTableMinX;
    double mTableMaxX;
    double mTableMinQ2;
    double mTableMaxQ2;
    double **mLookupTable; 

    AlphaStrong *mAlphaStrong;
};

inline void DglapEvolution::useLookupTable(bool val) {mUseLookupTable = val;}

inline bool DglapEvolution::lookupTableIsUsed() const
{
    return mUseLookupTable && mLookupTableIsFilled;
}

inline DglapEvolution& DglapEvolution::instance()
{
    if (!mInstance) mInstance = new DglapEvolution;
    return *mInstance;
}

#endif

